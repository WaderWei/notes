# 常见问题及解决方案

### 主键使用数字还是UUID

##### 用数字

* 优点
  * 占用存储空间小
  * 效率高（自增）
  * int建立索引比varchar检索速度更快
* 缺点
  * 自增有规律，安全性低
  * 分布式主键可能重复

##### 用UUID

* 优点

  * UUID 可以解决分布式ID不重复，跨服务器合并数据方便。
  * UUID 可以在提交数据库之前就获取，不需要多一个 select 语句
  * 不是所有数据库都支持自增ID
  * `UUID`的性能并不比`自增ID`差很多，这取决于`UUID`的生成算法。

* 缺点

  * 占用存储空间大
  * 效率低

  

uuid：优点

![1570628880127](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570628880127.png)

​		缺点：

![1570628907354](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570628907354.png)

![1570628950259](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570628950259.png)

利用MyCat生成连续的数字主键

![1570628974276](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570628974276.png)

这里建议不论什么情况下都不用uuid。



### 如何在线修改数据表结构

![1570629145359](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629145359.png)

生产环境，千万不要直接修改表结构

![1570629184624](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629184624.png)

**不锁表在线修改表结构**

![1570629251385](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629251385.png)

新建虚拟机实例安装此工具

![1570629310276](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629310276.png)

![1570629378480](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629378480.png)![1570629426539](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629426539.png)![1570629459820](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570629459820.png)

### 订单号和流水号之间的关系

![1570708776522](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570708776522.png)

```java
//生成流水号逻辑
public static void main(String[] args) {
        String orderCode = createOrderCode("O", "1001", "40010", "20191010");
        System.out.println(orderCode);
    }

    /**
     * 生成流水号
     * @param type           o-线上 d-线下
     * @param organizationId 零售店/仓库 编号
     * @param spgId          品类编号
     * @param data           购物日期
     * @return
     */
    public static String createOrderCode(String type, String organizationId, String spgId, String data) {
        StringBuilder code = new StringBuilder();
        code.append(type).append(organizationId).append(spgId).append(data);
        //生成10位随机数
        ThreadLocalRandom.current().ints(0, 9).limit(10).forEach(num -> {
            code.append(num);
        });
        return code.toString();
    }
```



### 是逻辑删除还是物理删除

##### 物理删除的问题

1. 物理删除是真删除，所以数据恢复起来的难度很大
2. 物理删除会造成主键不连续，导致分页查询变慢

![1570710559007](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570710559007.png)

#### 逻辑删除

![1570710599559](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570710599559.png)

可以写一个定时器，每天凌晨3点将逻辑删除的数据转移到历史表中

 **复制一个表**

![1570710835054](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570710835054.png)

### 千万条数据，如何快速分页 

最后一个要查询3s多

![1570711808957](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570711808957.png)

1. 利用主键索引来加速分页查询

   ![1570711892065](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570711892065.png)

   

2. 一般表都有逻辑删除，主键并不连续，因此不能用上面方法

   > 利用主键索引加速，再做表连接查询

   ![1570712215776](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570712215776.png)

3. 其它解决办法

   > 业务上限定用户查找很靠后的数据



### 读多写少，读少写多，读多写多

* 读多写少
  1. 电商系统：一般都是浏览，很少下单
  2. 论坛系统：一般都是浏览，很少评论

* 读少写多

  1.  滴滴系统：实时上传定位数据到数据库
  2. 大学刷卡系统：一般都是刷卡，很少被查询

  ![1570713192453](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713192453.png)

  ![1570713235441](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713235441.png)

  冷热分离：冷的数据（不经常查询的数据）保存在ToKuDB引擎的数据库中



![1570713476937](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713476937.png)

![1570713549227](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713549227.png)

### 删改数据如何避免锁表

![1570713689551](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713689551.png)

![1570713753338](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713753338.png)

![1570713782904](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570713782904.png)

![1570714263100](H:\gitwork\notes\VMware\常见问题及解决方案.assets\1570714263100.png)

**理解**：
我自己测试了一下，有点明白了，总结一下：

1. 不管是S锁还是X锁，我们都不能主动加在增删改操作语句上，
   所以S锁和X锁是针对查询语句的（查询语句默认没有加锁），如果加了锁，就能保证了一个事务在查询数据时，这些数据不会被其它事务所修改。

2. 如果事务T的查询语句对数据加了S锁，其它事务的查询语句加了S锁能查出数据，但加了X锁就要等到事务T释放S锁了；
如果事务T对数据加了X锁，其它事务的查询语句如果加了锁（x或s锁）就要等待事务T释放了X锁。

##### 减少并发操作的锁冲突

把复杂的SQL语句，拆分成多条简单的SQL语句



