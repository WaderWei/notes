# 常见问题及解决方案2

### 如何实现商品秒杀

![1570798568319](.\常见问题及解决方案2.assets\1570798568319.png)

![1570798703491](.\常见问题及解决方案2.assets\1570798703491.png)

1. A顾客查询是否有库存，有1个，执行库存减一的事务（未执行完）；
2. B顾客查询是否有库存，有一个，执行库存减一的事务，执行成功，库存为0；
3. A顾客事务执行完毕，库存为-1，

![1570799109438](.\常见问题及解决方案2.assets\1570799109438.png)

第一种：让事务串行化执行，serializable级别是锁表的，保证同一时刻只有一个事务在执行，实践中会极大影响效率，不可行。

第二种：对可能存在并发修改的表加上版本号，每次修改的时候对应版本号才能修改，否则修改不成功。



![1570799441341](.\常见问题及解决方案2.assets\1570799441341.png)

![1570799505554](.\常见问题及解决方案2.assets\1570799505554.png)

![1570799595079](.\常见问题及解决方案2.assets\1570799595079.png)

![1570799635069](.\常见问题及解决方案2.assets\1570799635069.png)

不管是mysql还是redis，只要在一个操作还没有及时修改库存的时候，另一个操作又来查询库存，都会造成超售现象。



![1570799777554](.\常见问题及解决方案2.assets\1570799777554.png)

![1570801411331](.\常见问题及解决方案2.assets\1570801411331.png)

客户端A在修改数据之前，会先观察要修改的数据，相当于拿到数据的版本号，然后编写命令，一次性提交命令，期间不会被其它事务所打断。

但可能客户端A在本地缓存命令的时候，B对数据进行了修改，但没关系，A发现版本号不同，修改数据会失败。



![1570801759767](.\常见问题及解决方案2.assets\1570801759767.png)

**开启事务之前，必须要先观察要修改的数据。**

![1570801852228](.\常见问题及解决方案2.assets\1570801852228.png)

在执行EXEC之前，所有的命令只是被缓存到本地中（这时候可能会被其它redis事务把数据给修改，但因为监听了操作记录，即使其它事务修改了数据，本次事务就不会执行成功），而不是执行。当执行EXEC时，会将命令发给redis执行，执行期间不会被打断。



### 编写秒杀代码

![1570802340559](.\常见问题及解决方案2.assets\1570802340559.png)

**KillTask代码**

![1570802543017](.\常见问题及解决方案2.assets\1570802543017.png)

这段代码可能有问题，但想想又没有问题，注意测试。

有人讲：把watch放在get("kill_num")之前，但其实感觉放在前或后没什么区别，因为当足够多的客户端连进来时，不管在前还是在后，一定会导致多个客户端监听相同的kill_num，但应该只有一个客户端能执行成功才对，因为一个客户端执行成功后，其它客户端版本号应该都对不上了。

![1570803855499](.\常见问题及解决方案2.assets\1570803855499.png)



### 数据库编程

![1571146979160](H:\gitwork\notes\mysql\常见问题及解决方案2.assets\1571146979160.png)

不管是存储过程，函数还是触发器，他们都是预先编译好的，省去了数据库语法校验等过程，执行的速度比sql语句快很多，由程序计算的压力转移到数据库这边，

**针对单节点，使用本地编程要好一点，执行速度快**

**针对集群，应该放弃使用本地编程，因为他们都是在本地数据库执行，无法兼容集群场景**

#### 存储过程与函数的区别

函数是对一些数据进行**计算**，仅且只能返回一个值；

存储过程是对数据的处理，返回值可有可无，可返回多条数据。



### 如何避免篡改商品信息

![1571147992599](.\常见问题及解决方案2.assets\1571147992599.png)

![1571148105339](.\常见问题及解决方案2.assets\1571148105339.png)

**增加一张spu_old表**

![1571148778557](.\常见问题及解决方案2.assets\1571148778557.png)

spu_old中的spu_id 可重复，因为一个spu可能被修改多次

假如一个spu被修改，那么将这条记录完整的保存到spu_old(自增)表中，sku不变。



**增加一张sku_old表**

![1571148953470](.\常见问题及解决方案2.assets\1571148953470.png)

old_id : 对应的是spu_old中的id，因为spu_old中的spu_id是重复的，并不能根据sku_old中的spu_id确定是哪一个对应的spu

假如修改一条sku信息，要将原来sku中的此条记录保存到sku_old表中，还要将对应的spu的那条数据保存到spu_old表中，并关联old_id.



**修改t_order_detail，增加old_id**

![1571150431618](.\常见问题及解决方案2.assets\1571150431618.png)

old_id：对应spu_old的id，可空，如果为空，则表示此商品没有经过修改，若果不为空，则关联对应的spu_old表的id。



### 如何抵御XSS攻击

![1571150910869](.\常见问题及解决方案2.assets\1571150910869.png)

![1571151216604](.\常见问题及解决方案2.assets\1571151216604.png)

![1571151264341](.\常见问题及解决方案2.assets\1571151264341.png)

### java中过滤恶意脚本

![1571151330187](.\常见问题及解决方案2.assets\1571151330187.png)

![1571151946958](.\常见问题及解决方案2.assets\1571151946958.png)

保存数据库的时候，对数据利用antiSamy对恶意脚本进行过滤

springboot：[xss防御](https://www.jianshu.com/p/3e4b00b8ff3a)



